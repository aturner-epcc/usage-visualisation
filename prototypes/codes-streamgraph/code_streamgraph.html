<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <script src="js/jquery.js"></script>
    <script src="js/d3.min.js"></script>
    <link rel="stylesheet" href="style/code-streamgraph.css">
  </head>
  <body>
    <div id="vis"></div>
    <div id="body">
      <div id="footer">
        <span>â€¦</span>
        <div class="hint">mousewheel to zoom, drag to pan</div>
      </div>
    </div>
    <script type="text/javascript">

var paddingBottom = 20;
var width = 880;
var height = 600 - paddingBottom;
var duration = 750;

var x = d3.time.scale()
  .range([0, width]);

var y = d3.scale.linear()
  .range([height, 0]);

var color = d3.scale.category20();

var area = d3.svg.area()
    .interpolate("basis")
    .x(function(d) { return x(d.date); });

var line = d3.svg.line()
    .interpolate("basis")
    .x(function(d) { return x(d.date); });

var stack = d3.layout.stack()
  .values(function(d) { return d.values; })
  .x(function(d) { return d.date; })
  .y(function(d) { return d.count; })
  .out(function(d,y0,y) { return (d.count0 = y0) === 0; })
  .order("reverse");

var xAxis = d3.svg.axis()
     .scale(x)
     .tickSize(-height)
     .tickFormat(d3.time.format('%a %d'));

var data = null

var svg = d3.select("#vis").append("svg")
            .attr("width", width)
            .attr("height", height + paddingBottom);

var start = function() {

  // first, lets setup our x scale domain
  // this assumes that the dates in our data are in order
  var minDate = d3.min(data, function(d) { return d.values[0].date;});
  var maxDate = d3.max(data, function(d) { return d.values[d.values.length - 1].date;});
  x.domain([minDate, maxDate]);

  // D3's axis functionality usually works great
  // however, I was having some aesthetic issues
  // with the tick placement
  // here I extract out every other day - and 
  // manually specify these values as the tick 
  // values
  dates = data[0].values.map(function(v) { return v.date; });
  index = 0;
  dates = dates.filter(function(d) {
    index += 1;
    return (index % 2) === 0;
  });


  xAxis.tickValues(dates);

  // the axis lines will go behind
  // the rest of the display, so create
  // it first
  svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);

  // I want the streamgraph to emanate from the
  // middle of the chart. 
  // we can set the area's y0 and y1 values to 
  // constants to achieve this effect.
  area.y0(height / 2)
      .y1(height / 2);

  // now we bind our data to create
  // a new group for each request type
  var g = svg.selectAll(".request")
         .data(data)
         .enter();

  var requests = g.append("g")
         .attr("class", "request");

  // add some paths that will
  // be used to display the lines and
  // areas that make up the charts
  requests.append("path")
    .attr("class", "area")
    .style("fill", function(d) { return color(d.key);})
    .attr("d", function(d) { return area(d.values);});

  requests.append("path")
    .attr("class", "line")
    .style("stroke-opacity", 1e-6);

  // create the legend on the side of the page
  // createLegend()

  // default to streamgraph display
  streamgraph();
}

var streamgraph = function() {
  // 'wiggle' is the offset to use 
  // for streamgraphs.
  stack.offset("wiggle");

  // the stack layout will set the count0 attribute
  // of our data
  stack(data);

  // reset our y domain and range so that it 
  // accommodates the highest value + offset
  y.domain([0, d3.max(data[0].values.map(function(d) { return d.count0 + d.count; }))])
    .range([height, 0]);

  // the line will be placed along the 
  // baseline of the streams, but will
  // be faded away by the transition below.
  // this positioning is just for smooth transitioning
  // from the area chart
  line.y(function(d) { return y(d.count0);});

  // setup the area generator to utilize
  // the count0 values created from the stack
  // layout
  area.y0(function(d) { return y(d.count0); })
    .y1(function(d) { return y(d.count0 + d.count); });

  // here we create the transition
  // and modify the area and line for
  // each request group through postselection
  var t = svg.selectAll(".request")
    .transition()
    .duration(duration);
 
  // D3 will take care of the details of transitioning
  // between the current state of the elements and
  // this new line path and opacity.
  t.select("path.area")
    .style("fill-opacity", 1.0)
    .attr("d", function(d) { return area(d.values);} );

  // 1e-6 is the smallest number in JS that
  // won't get converted to scientific notation. 
  // as scientific notation is not supported by CSS,
  // we need to use this as the low value so that the 
  // line doesn't reappear due to an invalid number.
  t.select("path.line")
    .style("stroke-opacity", 1e-6)
    .attr("d", function(d) { return line(d.values); });
}

var display = function(error, rawData) {

  data = rawData;

  console.log(rawData);

  // a parser to convert our date string into a JS time object.
  var parseTime = d3.time.format.utc("%x").parse

  // go through each data entry and set its
  // date and count property
  data.forEach(function(s) {
    s.values.forEach(function(d) {
      d.date = parseTime(d.date);
      d.count = parseFloat(d.count);
    })

    // precompute the largest count value for each request type
    s.maxCount = d3.max(s.values, function(d) { return d.count; });
  });

  data.sort(function(a,b) { return b.maxCount - a.maxCount; });

  start();
}

$(document).ready(function() {
   d3.json("data/requests.json", display);
});

    </script>
  </body>
</html>

